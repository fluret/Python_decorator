# Énoncé : Créer le décorateur `type_check`

## Objectif
Créer un décorateur `type_check` qui valide les types des arguments et, optionnellement, du retour d'une fonction avant son exécution.

## Principes
- Le décorateur reçoit une spécification de type pour chaque paramètre par nom.
- Il peut aussi accepter un type de retour via la clé `return_type`.
- En cas de non-conformité, il lève une `TypeError` avec un message explicite.
- Si tout est conforme, la fonction s'exécute normalement.
- Le décorateur peut être utilisé sans paramètres (`@type_check`) pour utiliser uniquement les annotations Python.

## Contraintes
- Préserver `__name__` et `__doc__` via `functools.wraps`.
- Supporter arguments positionnels et nommés (`*args`, `**kwargs`).
- Ne pas modifier les valeurs : seulement valider.
- Messages d'erreur clairs : ex. "Argument 'a' attendu int, reçu float".

## Spécifications minimales
- **Signature avec paramètres** : `@type_check(a=int, b=str, return_type=list)` appliqué à une fonction `def f(a, b): ...`.
- **Signature sans paramètres** : `@type_check` utilisé sur une fonction avec annotations de type.
- **Paramètres non renseignés** : ne pas être validés (ou, en variante, utiliser les annotations Python si présentes).
- **Validation du retour** : seulement si `return_type` est spécifié dans le décorateur ou si une annotation `-> type` existe.

**Note** : `return` est un mot-clé réservé Python, donc on utilise `return_type` comme nom de paramètre.

## Bonus (optionnel)
- Utiliser les annotations de type (`__annotations__`) par défaut si le décorateur est appelé sans arguments : `@type_check` lit les annotations et valide.
- Support de `typing` (ex: `List[int]`, `Tuple[str, ...]`, `Optional[int]`, `Union[str, int]`).
- Validation de conteneurs : vérifier récursivement le contenu des listes/tuples/dicts si un type paramétré est fourni.

## Exemples d'utilisation

### Spécification explicite
```python
@type_check(a=int, b=str, return_type=str)
def concat(a, b):
    return f"{a}:{b}"

concat(3, "x")       # ✓ Passe
concat("3", "x")     # ✗ TypeError: Argument 'a' attendu int, reçu str
```

### Avec annotations Python
```python
@type_check
def somme(a: int, b: int) -> int:
    return a + b

somme(1, 2)      # ✓ Passe
somme(1, "2")    # ✗ TypeError: Argument 'b' attendu int, reçu str
```

### Paramètres nommés
```python
@type_check(x=int, y=int)
def multiplier(x, y):
    return x * y

multiplier(2, 3)     # ✓ Passe
multiplier(x=2, y=3) # ✓ Passe
multiplier(2, "3")   # ✗ TypeError
```

### Validation du type de retour
```python
@type_check(vals=list, return_type=int)
def count(vals):
    return len(vals)

count([1, 2, 3])     # ✓ Passe (retourne int)
count("abc")         # ✗ TypeError: Argument 'vals' attendu list, reçu str
```

## Cas à tester
- ✓ Appel correct avec arguments positionnels.
- ✓ Appel correct avec arguments nommés.
- ✗ Type incorrect pour argument positional.
- ✗ Type incorrect pour argument nommé.
- ✗ Type de retour incorrect si `return_type` est défini.
- ✓ Préservation de `__name__` et `__doc__`.
- ✓ Paramètres avec valeurs par défaut.
- ✗ Absence d'argument obligatoire (comportement normal de Python).
- ✓ Utilisation sans paramètres (`@type_check`) avec annotations.
